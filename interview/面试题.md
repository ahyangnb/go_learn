# 相关资源

go语言中文文档：

https://www.bookstack.cn/read/topgoer/efbecba7753baa7e.md

http://www.topgoer.com/

goWeb编程

https://www.kancloud.cn/kancloud/web-application-with-golang/44178

李文周博客

https://www.liwenzhou.com/archives/

超全golang面试题合集+golang学习指南+golang知识图谱 

https://juejin.cn/post/6948954576045211678

https://github.com/xiaobaiTech/golangFamily

### Go 语言

- [Go 语言笔试面试题(基础语法)](https://geektutu.com/post/qa-golang-1.html)
- [Go 语言笔试面试题(实现原理)](https://geektutu.com/post/qa-golang-2.html)
- [Go 语言笔试面试题(并发编程)](https://geektutu.com/post/qa-golang-3.html)
- [Go 语言笔试面试题(代码输出)](https://geektutu.com/post/qa-golang-c1.html)

## 你用过的框架有哪些，为什么使用ta？

##### 网络请求：`fasthttp`

[fasthttp](https://studygolang.com/articles/5077) 是 Go 的一款不同于标准库 `net/http` 的 HTTP 实现。fasthttp 的性能可以达到标准库的 10 倍，说明他魔性的实现方式。主要的点在于四个方面：

- `net/http` 的实现是一个连接新建一个 goroutine；`fasthttp` 是利用一个 worker 复用 goroutine，减轻 runtime 调度 goroutine 的压力
- `net/http` 解析的请求数据很多放在 `map[string]string`(http.Header) 或 `map[string][]string`(http.Request.Form)，有不必要的 []byte 到 string 的转换，是可以规避的
- `net/http` 解析 HTTP 请求每次生成新的 `*http.Request` 和 `http.ResponseWriter`; `fasthttp` 解析 HTTP 数据到 `*fasthttp.RequestCtx`，然后使用 `sync.Pool` 复用结构实例，减少对象的数量
- `fasthttp` 会延迟解析 HTTP 请求中的数据，尤其是 Body 部分。这样节省了很多不直接操作 Body 的情况的消耗

##### json处理：`json-iterator`
- jsoniter （ json-iterator ）是一款快且灵活的 JSON 解析器
- Jsoniter 是最快的 JSON 解析器。它最多能比普通的解析器快 10 倍之多,
- 独特的 iterator api 能够直接遍历 JSON ，极致性能！ 0 内存分配！

##### orm数据库处理:`GORM`
gorm是一个使用Go语言编写的ORM框架。文档齐全，对开发者友好，支持主流数据库。

##### orm数据库处理:`xorm`

简单而强大的Go语言ORM库. 可以让数据库操作非常简便。

##### es相关 [elastic](https://www.liwenzhou.com/posts/Go/go_elasticsearch/)
Elasticsearch（简称ES）是一个基于Lucene构建的开源、分布式、RESTful接口的全文搜索引擎。Elasticsearch还是一个分布式文档数据库，其中每个字段均可被索引，而且每个字段的数据均可被搜索，ES能够横向扩展至数以百计的服务器存储以及处理PB级的数据。可以在极短的时间内存储、搜索和分析大量的数据。通常作为具有复杂搜索场景情况下的核心发动机。

##### mq【消息中间件】相关：

- Kafka

- Rocketmq

- Rabbitmq

##### Redis相关：redis

##### 配置相关

- yaml
- toml

##### excel相关：excelize

##### ppt相关：present



## 常用包

math、net/http、fmt、io、csv、json、time、strconv、strings

## 问题排查

- trace
  
  查频繁gc

- pprof

  内存泄漏、cpu过高、程序慢、锁的争用、程序阻塞

# 框架

- web框架

  gin、beego

- 微服务框架

  kratos

# 公众号

码农桃花源、脑子进煎鱼了、go语言中文网、golang小白成长记

## Redis支持的数据类型分别是？

string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。

## json包变量不加tag会怎么样？

>  [来源](https://juejin.cn/post/6844904190636982285)

转为`json`后首字母`小写的`不管加不加tag`都不能`转为`json`里的内容，而`大写的`加了`tag`可以`取别名`，不加`tag`则`json`内的字段跟结构体字段`原名一致`。


## 知道golang的**内存逃逸**吗？什么情况下会发生内存逃逸？

> [来源](https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483686&idx=1&sn=e48c51107191f02da5751a19a54f7d41&chksm=9aee288fad99a199c126d5ff735af7320356ce4bb5753ae59ac6231e596354499414b5705b79&token=2092782362&lang=zh_CN#rd)

`golang程序变量`会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在`栈上`分配。否则就说它 `逃逸` 了，必须在`堆上分配`。

能引起变量逃逸到堆上的**典型情况**：

- **在方法内把局部变量指针返回** 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
- **发送指针或带有指针的值到 channel 中。** 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
- **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
- **在 interface 类型上调用方法。** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。

## 怎么避免内存逃逸？

> [来源](https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483692&idx=1&sn=d5d34fad7a4553e0b9d5714385b7af48&chksm=9aee2885ad99a193253c1e57bd361b3f5af643d3ba14f56f25c0c5551990c848c6f30a5ca23e&token=961196008&lang=zh_CN#rd)

在`runtime/stubs.go:133`有个函数叫`noescape`。`noescape`可以在逃逸分析中**隐藏一个指针**。让这个指针在逃逸分析中**不会被检测为逃逸**。

```
noescape() 函数的作用是遮蔽输入和输出的依赖关系。使编译器不认为 p 会通过 x 逃逸， 因为 uintptr() 产生的引用是编译器无法理解的。

内置的 uintptr 类型是一个真正的指针类型，但是在编译器层面，它只是一个存储一个 指针地址 的 int 类型。代码的最后一行返回 unsafe.Pointer 也是一个 int。

noescape() 在 runtime 包中使用 unsafe.Pointer 的地方被大量使用。如果作者清楚被 unsafe.Pointer 引用的数据肯定不会被逃逸，但编译器却不知道的情况下，这是很有用的。
```

## 字符串转成byte数组，会发生内存拷贝吗？

> [来源](https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483669&idx=1&sn=88f754ddabc04eb3f66ba8ac37ee1461&chksm=9aee28bcad99a1aa1ada41cfccaffc7ef4719a9bc11c1bef45b7d1b5427c1faa12d8d0c3156f&token=2092782362&lang=zh_CN&scene=21#wechat_redirect)

字符串转成切片，会产生拷贝。严格来说，只要是发生类型强转都会发生内存拷贝。

## 频繁的内存拷贝操作听起来对性能不大友好。**有没有什么办法可以在字符串转成切片的时候不用发生拷贝呢？**

需要在底层进行转换

- `StringHeader` 是`字符串`在go的底层结构。

```
type StringHeader struct {
 Data uintptr
 Len  int
}
```

- `SliceHeader` 是`切片`在go的底层结构。

```
type SliceHeader struct {
 Data uintptr
 Len  int
 Cap  int
}
```

- 那么如果想要在底层转换二者，只需要把 `StringHeader` 的地址强转成 `SliceHeader` 就行。那么go有个很强的包叫 `unsafe` 。

- - 1.`unsafe.Pointer(&a)`方法可以得到变量`a`的地址。
  - 2.`(*reflect.StringHeader)(unsafe.Pointer(&a))` 可以把字符串a转成底层结构的形式。
  - 3.`(*[]byte)(unsafe.Pointer(&ssh))` 可以把ssh底层结构体转成byte的切片的指针。
  - 4.再通过 `*`转为指针指向的实际内容。

## 拷贝大切片一定比小切片代价大吗？
> [来源](https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483674&idx=1&sn=ce4b5fee48c54ff69127ef2bd5d91427&chksm=9aee28b3ad99a1a57eed7651a16fd4bdc35ff23937e423c5e1322a234652fd135f1a16abbece&token=2092782362&lang=zh_CN#rd)

并不是，所有切片的大小相同；**三个字段**（一个 uintptr，两个int）。切片中的第一个字是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字。所以 **拷贝大切片跟小切片的代价应该是一样的**。

> 大切片跟小切片的区别无非就是 `Len` 和 `Cap`的值比小切片的这两个值大一些，如果发生拷贝，本质上就是拷贝上面的三个字段。

## 能说说uintptr和unsafe.Pointer的区别吗？
> [来源](https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483679&idx=1&sn=7075859e59741b1d0a81dc472b8ce45f&chksm=9aee28b6ad99a1a0599416886660d9ea56bd7fec18841af0e5fe86c3daea3973732a83d7eabb&token=2092782362&lang=zh_CN#rd)
- unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；
- 而uintptr是用于指针运算的，GC 不把 uintptr 当指针，也就是说 uintptr 无法持有对象， uintptr 类型的目标会被回收；
- unsafe.Pointer 可以和 普通指针 进行相互转换；
- unsafe.Pointer 可以和 uintptr 进行相互转换。

## 对已经关闭的的chan进行读写，会怎么样？为什么？

> [来源](https://juejin.cn/post/6844904199151435783)

读**已经关闭**的 `chan` 能一直读到东西，但是读到的内容根据通道内`关闭前`是否有元素而不同。

- 如果 `chan` 关闭前，`buffer` 内有元素**还未读** , 会正确读到 `chan` 内的值，且返回的第二个 bool 值（是否读成功）为 `true`。
- 如果 `chan` 关闭前，`buffer` 内有元素**已经被读完**，`chan` 内无值，接下来所有接收的值都会非阻塞直接成功，返回 `channel` 元素的**零值**，但是第二个 `bool` 值一直为 `false`。

写**已经关闭**的 `chan` 会 `panic`

