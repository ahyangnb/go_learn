## json包变量不加tag会怎么样？

>  [来源](https://juejin.cn/post/6844904190636982285)

转为`json`后首字母`小写的`不管加不加tag`都不能`转为`json`里的内容，而`大写的`加了`tag`可以`取别名`，不加`tag`则`json`内的字段跟结构体字段`原名一致`。

## 怎么避免内存逃逸？

> [来源](https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483692&idx=1&sn=d5d34fad7a4553e0b9d5714385b7af48&chksm=9aee2885ad99a193253c1e57bd361b3f5af643d3ba14f56f25c0c5551990c848c6f30a5ca23e&token=961196008&lang=zh_CN#rd)

在`runtime/stubs.go:133`有个函数叫`noescape`。`noescape`可以在逃逸分析中**隐藏一个指针**。让这个指针在逃逸分析中**不会被检测为逃逸**。

```
noescape() 函数的作用是遮蔽输入和输出的依赖关系。使编译器不认为 p 会通过 x 逃逸， 因为 uintptr() 产生的引用是编译器无法理解的。

内置的 uintptr 类型是一个真正的指针类型，但是在编译器层面，它只是一个存储一个 指针地址 的 int 类型。代码的最后一行返回 unsafe.Pointer 也是一个 int。

noescape() 在 runtime 包中使用 unsafe.Pointer 的地方被大量使用。如果作者清楚被 unsafe.Pointer 引用的数据肯定不会被逃逸，但编译器却不知道的情况下，这是很有用的。
```

## 字符串转成byte数组，会发生内存拷贝吗？

> [来源](https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483669&idx=1&sn=88f754ddabc04eb3f66ba8ac37ee1461&chksm=9aee28bcad99a1aa1ada41cfccaffc7ef4719a9bc11c1bef45b7d1b5427c1faa12d8d0c3156f&token=2092782362&lang=zh_CN&scene=21#wechat_redirect)

字符串转成切片，会产生拷贝。严格来说，只要是发生类型强转都会发生内存拷贝。

## 频繁的内存拷贝操作听起来对性能不大友好。**有没有什么办法可以在字符串转成切片的时候不用发生拷贝呢？**

需要在底层进行转换

- `StringHeader` 是`字符串`在go的底层结构。

```
type StringHeader struct {
 Data uintptr
 Len  int
}
```

- `SliceHeader` 是`切片`在go的底层结构。

```
type SliceHeader struct {
 Data uintptr
 Len  int
 Cap  int
}
```

- 那么如果想要在底层转换二者，只需要把 `StringHeader` 的地址强转成 `SliceHeader` 就行。那么go有个很强的包叫 `unsafe` 。

- - 1.`unsafe.Pointer(&a)`方法可以得到变量`a`的地址。
  - 2.`(*reflect.StringHeader)(unsafe.Pointer(&a))` 可以把字符串a转成底层结构的形式。
  - 3.`(*[]byte)(unsafe.Pointer(&ssh))` 可以把ssh底层结构体转成byte的切片的指针。
  - 4.再通过 `*`转为指针指向的实际内容。